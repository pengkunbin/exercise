# 最长递增子序列的动态规划解法

## 算法思路

动态规划是解决最长递增子序列问题的经典方法，虽然时间复杂度为 O(n²)，但思路直观且易于理解。

## 核心思想

1. **状态定义**：`dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。

2. **状态转移方程**：
   ```
   dp[i] = max(dp[j] + 1) 其中 0 ≤ j < i 且 nums[j] < nums[i]
   ```
   或者如果找不到满足条件的 j，则 `dp[i] = 1`（即只包含自己的子序列）。

3. **初始状态**：所有 `dp[i]` 初始化为 1，因为每个元素自身就构成长度为 1 的递增子序列。

4. **结果**：最终结果是 `dp` 数组中的最大值。

## 算法执行过程

以数组 `[0, 1, 0, 3, 2, 3]` 为例，执行过程如下：

1. 初始化：`dp = [1, 1, 1, 1, 1, 1]`

2. i = 1, nums[1] = 1
   - j = 0, nums[0] = 0 < nums[1]，dp[1] = max(1, dp[0] + 1) = 2
   - dp = [1, 2, 1, 1, 1, 1]

3. i = 2, nums[2] = 0
   - j = 0, nums[0] = 0 = nums[2]，不满足条件
   - j = 1, nums[1] = 1 > nums[2]，不满足条件
   - dp = [1, 2, 1, 1, 1, 1]

4. i = 3, nums[3] = 3
   - j = 0, nums[0] = 0 < nums[3]，dp[3] = max(1, dp[0] + 1) = 2
   - j = 1, nums[1] = 1 < nums[3]，dp[3] = max(2, dp[1] + 1) = 3
   - j = 2, nums[2] = 0 < nums[3]，dp[3] = max(3, dp[2] + 1) = 3
   - dp = [1, 2, 1, 3, 1, 1]

5. i = 4, nums[4] = 2
   - j = 0, nums[0] = 0 < nums[4]，dp[4] = max(1, dp[0] + 1) = 2
   - j = 1, nums[1] = 1 < nums[4]，dp[4] = max(2, dp[1] + 1) = 3
   - j = 2, nums[2] = 0 < nums[4]，dp[4] = max(3, dp[2] + 1) = 3
   - j = 3, nums[3] = 3 > nums[4]，不满足条件
   - dp = [1, 2, 1, 3, 3, 1]

6. i = 5, nums[5] = 3
   - j = 0, nums[0] = 0 < nums[5]，dp[5] = max(1, dp[0] + 1) = 2
   - j = 1, nums[1] = 1 < nums[5]，dp[5] = max(2, dp[1] + 1) = 3
   - j = 2, nums[2] = 0 < nums[5]，dp[5] = max(3, dp[2] + 1) = 3
   - j = 3, nums[3] = 3 = nums[5]，不满足条件
   - j = 4, nums[4] = 2 < nums[5]，dp[5] = max(3, dp[4] + 1) = 4
   - dp = [1, 2, 1, 3, 3, 4]

最终结果是 dp 数组中的最大值：4，表示最长递增子序列的长度为 4。

## 与贪心+二分查找方法的比较

### 动态规划方法
- **优点**：思路直观，易于理解和实现
- **缺点**：时间复杂度为 O(n²)，在处理大规模数据时效率较低

### 贪心+二分查找方法
- **优点**：时间复杂度为 O(n log n)，效率更高
- **缺点**：思路不够直观，理解起来较为复杂

## 结论

动态规划是解决最长递增子序列问题的经典方法，虽然效率不如贪心+二分查找方法，但其思路清晰，适合作为理解该问题的入门方法。在实际应用中，如果数据规模较大，建议使用贪心+二分查找方法以获得更好的性能。
